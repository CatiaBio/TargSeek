# Snakefile_analysis
# ------------------------------------------------------
# TargSeek Analysis Workflow
# 
# This pipeline performs MSA (MAFFT), alignment trimming, quality assessment,
# conservation analysis, epitope prediction, and report generation.
#
# Configuration: config/config_analysis.yaml
# Usage Guide: USAGE_ANALYSIS.txt
# 
# Quick Start: snakemake -s Snakefile_analysis all_analysis --cores 4
# ------------------------------------------------------

# Load configuration
configfile: "config/config_analysis.yaml"

# Define wildcard constraints to prevent ambiguous matches
wildcard_constraints:
    analysis="analysis[0-9]+",
    paramset="params[0-9]+",
    use_3d_dir="(no_3d|with_3d)"

# Helper function to get enabled processing paths
def get_enabled_paths(path_dict):
    """Get paths based on enabled processing options"""
    enabled_paths = []
    
    # Check if no_3d processing is enabled
    if config.get("processing", {}).get("enable_no_3d", True):
        enabled_paths.extend([
            path for key, path in path_dict.items() 
            if "no_3d" in key
        ])
    
    # Check if with_3d processing is enabled  
    if config.get("processing", {}).get("enable_with_3d", True):
        enabled_paths.extend([
            path for key, path in path_dict.items() 
            if "with_3d" in key
        ])
    
    return enabled_paths

# =============================================================================
# TARGET RULES
# =============================================================================

# Complete analysis pipeline - all stages
rule all_analysis:
    input:
        expand(
            get_enabled_paths({
                "conservation_main": config["paths"]["conservation"]["results_main"],
                "conservation_structure": config["paths"]["conservation"]["results_structure"],
                "raw_sequences_main": config["paths"]["conserved"]["raw_sequences_main"],
                "raw_sequences_structure": config["paths"]["conserved"]["raw_sequences_structure"],
                "trimmed_sequences_main": config["paths"]["conserved"]["trimmed_sequences_main"],
                "trimmed_sequences_structure": config["paths"]["conserved"]["trimmed_sequences_structure"]
            }),
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"],
            group=["positive", "negative"]
        ) + expand(
            [config["paths"]["epitopes"]["epitope_tables_sentinel"]],
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"]
        ) + expand(
            [config["paths"]["epitopes"]["conservation_report"]],
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"]
        )

# Partial pipeline targets - useful for testing and debugging individual stages
rule all_sequence_preparation:
    input:
        expand(
            [config["paths"]["sequence_prep"]["msa_sequence_refs"]] +
            [config["paths"]["msa"]["sequences"]] +
            get_enabled_paths({
                "sequences_main": config["paths"]["msa"]["sequences_main"],
                "sequences_structure": config["paths"]["msa"]["sequences_structure"]
            }),
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"],
            group=["positive", "negative"]
        ) + (expand(
            [config["paths"]["sequence_prep"]["selected_3d_paths"]],
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"],
            group=["positive", "negative"]
        ) if config.get("processing", {}).get("enable_with_3d", True) else [])

rule all_alignments:
    input:
        expand(
            get_enabled_paths({
                "alignments_main": config["paths"]["msa"]["alignments_main"],
                "alignments_structure": config["paths"]["msa"]["alignments_structure"],
                "trimmed_main": config["paths"]["msa"]["trimmed_main"],
                "trimmed_structure": config["paths"]["msa"]["trimmed_structure"]
            }),
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"],
            group=["positive", "negative"]
        )

rule all_quality_and_conservation:
    input:
        expand(
            get_enabled_paths({
                "quality_main": config["paths"]["quality"]["assessment_main"],
                "quality_structure": config["paths"]["quality"]["assessment_structure"],
                "conservation_main": config["paths"]["conservation"]["results_main"],
                "conservation_structure": config["paths"]["conservation"]["results_structure"],
                "raw_sequences_main": config["paths"]["conserved"]["raw_sequences_main"],
                "raw_sequences_structure": config["paths"]["conserved"]["raw_sequences_structure"],
                "trimmed_sequences_main": config["paths"]["conserved"]["trimmed_sequences_main"],
                "trimmed_sequences_structure": config["paths"]["conserved"]["trimmed_sequences_structure"]
            }),
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"],
            group=["positive", "negative"]
        )

rule all_conserved_sequences:
    input:
        expand(
            get_enabled_paths({
                "raw_sequences_main": config["paths"]["conserved"]["raw_sequences_main"],
                "raw_sequences_structure": config["paths"]["conserved"]["raw_sequences_structure"],
                "trimmed_sequences_main": config["paths"]["conserved"]["trimmed_sequences_main"],
                "trimmed_sequences_structure": config["paths"]["conserved"]["trimmed_sequences_structure"]
            }),
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"],
            group=["positive", "negative"]
        )

rule all_predictions_and_reports:
    input:
        expand(
            [
                config["paths"]["epitopes"]["epitope_tables_sentinel"],
                config["paths"]["epitopes"]["bepipred_predictions"] + "/3d_visualizations/visualization_complete.sentinel"
            ],
            analysis=config["species_batches"],
            paramset=config["quickgo_paramsets"]
        )

# =============================================================================
# ANALYSIS RULES
# =============================================================================

# ---------------------
# STAGE 1: Sequence Preparation
# ---------------------

# Select representative protein sequences for multiple sequence alignment
rule create_msa_sequence_references:
    input:
        gene_lists=config["paths"]["input"]["gene_lists"],
        protein_download_sentinel=config["paths"]["input"]["protein_download_sentinel"],
        structures_download_sentinel=config["paths"]["input"]["structures_download_sentinel"]
    output:
        directory(config["paths"]["sequence_prep"]["msa_sequence_refs"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}"
    script:
        config["scripts"]["sequence_prep"]["create_sequence_references"]

# STAGE 1: Create sequences with diversity-based selection (foundation for both no_3d and with_3d)
rule create_sequences:
    input:
        reference_dir=config["paths"]["sequence_prep"]["msa_sequence_refs"]
    output:
        sequences_dir=directory(config["paths"]["msa"]["sequences"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}"
    script:
        config["scripts"]["sequence_prep"]["create_sequences"]

# STAGE 2: Select optimal 3D structures using 5 sequences from MSA (only when 3D processing is enabled)
rule select_3d_from_sequences:
    input:
        reference_dir=config["paths"]["sequence_prep"]["msa_sequence_refs"],
        sequences_dir=config["paths"]["msa"]["sequences"]
    output:
        selected_3d_paths=config["paths"]["sequence_prep"]["selected_3d_paths"],
        selected_3d_tsv=config["paths"]["sequence_prep"]["selected_3d_tsv"]
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}",
        structure_selection_method=config.get("structure_selection", {}).get("method", "similarity"),
        max_structures_per_gene=config.get("structure_selection", {}).get("max_structures_per_gene", 1),
        min_similarity_score=config.get("structure_selection", {}).get("min_similarity_score", 0.1),
        similarity_method=config.get("structure_selection", {}).get("similarity_method", "local_alignment")
    script:
        config["scripts"]["sequence_prep"]["select_3d_from_sequences"]

# STAGE 3: Create sequences with structure files (combines sequences + selected 3D structures)
rule create_sequences_with_structure:
    input:
        sequences_dir=config["paths"]["msa"]["sequences"],
        selected_3d_paths=config["paths"]["sequence_prep"]["selected_3d_paths"],
        fasta_structure_mapping="data/protein_structures/{analysis}_{paramset}_fasta_structure_mapping.tsv"
    output:
        sequences_with_structure_dir=directory(config["paths"]["msa"]["sequences_structure"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}"
    script:
        config["scripts"]["sequence_prep"]["create_final_msa"]

# ---------------------
# STAGE 2: Multiple Sequence Alignment
# ---------------------

# Perform multiple sequence alignments using MAFFT algorithm
rule run_all_mafft_for_group:
    input:
        msa_main=config["paths"]["msa"]["sequences_main"],
        msa_structure=config["paths"]["msa"]["sequences_structure"]
    output:
        main=directory(config["paths"]["msa"]["alignments_main"]),
        structure=directory(config["paths"]["msa"]["alignments_structure"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}",
        threads=config["mafft"]["threads"],
        enable_no_3d=config.get("processing", {}).get("enable_no_3d", True),
        enable_with_3d=config.get("processing", {}).get("enable_with_3d", True)
    script:
        config["scripts"]["msa"]["run_mafft_alignments"]

# Remove poorly aligned regions using ClipKIT automated trimming
rule trim_alignments:
    input:
        main=config["paths"]["msa"]["alignments_main"],
        structure=config["paths"]["msa"]["alignments_structure"]
    output:
        trim_main=directory(config["paths"]["msa"]["trimmed_main"]),
        trim_structure=directory(config["paths"]["msa"]["trimmed_structure"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}",
        use_3d=config.get("mafft", {}).get("use_3d_alignments", "no_3d"),
        trimming_method=config.get("trimming", {}).get("method", "clipkit"),
        clipkit_mode=config.get("trimming", {}).get("clipkit", {}).get("mode", "smart-gap"),
        enable_no_3d=config.get("processing", {}).get("enable_no_3d", True),
        enable_with_3d=config.get("processing", {}).get("enable_with_3d", True)
    script:
        config["scripts"]["msa"]["trim_alignments"]

# ---------------------
# STAGE 3: Quality Assessment
# ---------------------

# Evaluate multiple sequence alignment quality before and after trimming
rule assess_alignment_quality:
    input:
        main=config["paths"]["msa"]["alignments_main"],
        structure=config["paths"]["msa"]["alignments_structure"],
        trim_main=config["paths"]["msa"]["trimmed_main"],
        trim_structure=config["paths"]["msa"]["trimmed_structure"]
    output:
        main=directory(config["paths"]["quality"]["assessment_main"]),
        structure=directory(config["paths"]["quality"]["assessment_structure"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}",
        use_3d=config.get("mafft", {}).get("use_3d_alignments", "no_3d")
    script:
        config["scripts"]["quality"]["assess_alignment_quality"]

# ---------------------
# STAGE 4: Conservation Analysis
# ---------------------

# Calculate amino acid conservation patterns from optimal alignments
rule analyze_conservation:
    input:
        main=config["paths"]["msa"]["alignments_main"],
        structure=config["paths"]["msa"]["alignments_structure"],
        trim_main=config["paths"]["msa"]["trimmed_main"],
        trim_structure=config["paths"]["msa"]["trimmed_structure"],
        quality_main=config["paths"]["quality"]["assessment_main"],
        quality_structure=config["paths"]["quality"]["assessment_structure"]
    output:
        main=directory(config["paths"]["conservation"]["results_main"]),
        structure=directory(config["paths"]["conservation"]["results_structure"])
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}",
        use_3d=config.get("mafft", {}).get("use_3d_alignments", "no_3d"),
        create_logos=config.get("conservation", {}).get("create_logos", False),
        enable_no_3d=config.get("processing", {}).get("enable_no_3d", True),
        enable_with_3d=config.get("processing", {}).get("enable_with_3d", True)
    script:
        config["scripts"]["conservation"]["analyze_conservation"]

# ---------------------
# STAGE 5: Conserved Sequence Extraction
# ---------------------

# Extract conserved sequences (≥5 amino acids) from MSAs with conservation percentages
def get_conserved_inputs(wildcards):
    """Get inputs based on enabled processing options"""
    inputs = {}
    
    if config.get("processing", {}).get("enable_no_3d", True):
        inputs["raw_main"] = config["paths"]["msa"]["alignments_main"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
        inputs["trimmed_main"] = config["paths"]["msa"]["trimmed_main"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
    
    if config.get("processing", {}).get("enable_with_3d", True):
        inputs["raw_structure"] = config["paths"]["msa"]["alignments_structure"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
        inputs["trimmed_structure"] = config["paths"]["msa"]["trimmed_structure"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
    
    return inputs

def get_conserved_outputs(wildcards):
    """Get outputs based on enabled processing options"""
    outputs = {}
    
    if config.get("processing", {}).get("enable_no_3d", True):
        outputs["raw_sequences_main"] = config["paths"]["conserved"]["raw_sequences_main"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
        outputs["trimmed_sequences_main"] = config["paths"]["conserved"]["trimmed_sequences_main"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
    
    if config.get("processing", {}).get("enable_with_3d", True):
        outputs["raw_sequences_structure"] = config["paths"]["conserved"]["raw_sequences_structure"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
        outputs["trimmed_sequences_structure"] = config["paths"]["conserved"]["trimmed_sequences_structure"].format(analysis=wildcards.analysis, paramset=wildcards.paramset, group=wildcards.group)
    
    return outputs

rule extract_conserved_sequences:
    input:
        raw_structure=config["paths"]["msa"]["alignments_structure"],
        trimmed_structure=config["paths"]["msa"]["trimmed_structure"]
    output:
        raw_sequences_structure=config["paths"]["conserved"]["raw_sequences_structure"],
        trimmed_sequences_structure=config["paths"]["conserved"]["trimmed_sequences_structure"]
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        group="{group}",
        min_conservation=config.get("conserved", {}).get("min_conservation", 0.5),
        min_length=config.get("conserved", {}).get("min_length", 5),
        enable_no_3d=config.get("processing", {}).get("enable_no_3d", True),
        enable_with_3d=config.get("processing", {}).get("enable_with_3d", True)
    script:
        config["scripts"]["conserved"]["extract_sequences"]

# ---------------------
# STAGE 6: Epitope Prediction
# ---------------------

# NOTE: create_used_structures_mapping rule removed - now using comprehensive
# PDB numbering mapping from download pipeline: data/protein_structures/{analysis}_{paramset}_pdb_numbering_mapping.tsv

# Predict B-cell epitopes using BepiPred 3.0 on selected 3D structure sequences
rule predict_epitopes_bepipred:
    input:
        selected_3d_paths_positive=config["paths"]["sequence_prep"]["selected_3d_paths"].replace("{group}", "positive"),
        selected_3d_paths_negative=config["paths"]["sequence_prep"]["selected_3d_paths"].replace("{group}", "negative")
    output:
        bepipred_sentinel=config["paths"]["epitopes"]["bepipred_predictions"] + "/bepipred_complete.sentinel"
    params:
        analysis="{analysis}",
        paramset="{paramset}"
    script:
        config["scripts"]["epitopes"]["predict_epitopes_bepipred"]

# Extract PDB amino acid numbering from selected 3D structure files
# Creates consolidated TSV file mapping selected structures to chains with numbering information
rule extract_pdb_numbering:
    input:
        fasta_structure_mapping="data/protein_structures/{analysis}_{paramset}_fasta_structure_mapping.tsv",
        selected_3d_paths_positive=config["paths"]["sequence_prep"]["selected_3d_paths"].replace("{group}", "positive"),
        selected_3d_paths_negative=config["paths"]["sequence_prep"]["selected_3d_paths"].replace("{group}", "negative")
    output:
        numbering_tsv="results/{analysis}_{paramset}/protein_analysis/pdb_numbering_mapping.tsv",
        numbering_sentinel="results/{analysis}_{paramset}/protein_analysis/pdb_numbering_complete.sentinel"
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        structures_dir="data/protein_structures/pdb_files"
    script:
        "scripts/protein_analysis/extract_pdb_numbering_selected.py"

# Create epitope tables from BepiPred 3.0 raw output
rule create_epitope_tables:
    input:
        bepipred_sentinel=config["paths"]["epitopes"]["bepipred_predictions"] + "/bepipred_complete.sentinel",
        pdb_numbering_sentinel="results/{analysis}_{paramset}/protein_analysis/pdb_numbering_complete.sentinel",
        pdb_numbering_mapping="results/{analysis}_{paramset}/protein_analysis/pdb_numbering_mapping.tsv"
    output:
        epitope_tables_sentinel=config["paths"]["epitopes"]["epitope_tables_sentinel"]
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        min_epitope_length=config.get("epitope_analysis", {}).get("min_epitope_length", 6)
    script:
        config["scripts"]["epitopes"]["create_epitope_tables"]


# Create 3D PyMOL visualizations of epitopes on protein structures
rule visualize_epitopes_pymol:
    input:
        epitope_tables_sentinel=config["paths"]["epitopes"]["epitope_tables_sentinel"], 
        structures_mapping="results/{analysis}_{paramset}/protein_analysis/sequences_with_structure/epitope_predictions_bepipred/used_structures_mapping.tsv"
    output:
        visualization_sentinel=config["paths"]["epitopes"]["bepipred_predictions"] + "/3d_visualizations/visualization_complete.sentinel"
    params:
        analysis="{analysis}",
        paramset="{paramset}"
    script:
        config["scripts"]["epitopes"]["visualize_epitopes_pymol"]

# ---------------------
# STAGE 6: Summaries and Reports
# ---------------------

# Run epitope conservation analysis for all genes
rule analyze_epitope_conservation:
    input:
        epitope_tables_sentinel=config["paths"]["epitopes"]["epitope_tables_sentinel"],
        msa_sequences_positive=lambda wildcards: config["paths"]["msa"]["sequences_structure"].replace("{group}", "positive").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
        msa_sequences_negative=lambda wildcards: config["paths"]["msa"]["sequences_structure"].replace("{group}", "negative").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
        selected_3d_positive=lambda wildcards: config["paths"]["sequence_prep"]["selected_3d_paths"].replace("{group}", "positive").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
        selected_3d_negative=lambda wildcards: config["paths"]["sequence_prep"]["selected_3d_paths"].replace("{group}", "negative").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
        pdb_numbering_mapping="data/protein_structures/{analysis}_{paramset}_pdb_numbering_mapping.tsv"
    output:
        conservation_analysis_sentinel=config["paths"]["epitopes"]["conservation_analysis_sentinel"]
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        conservation_analysis_dir=lambda wildcards: config["paths"]["epitopes"]["conservation_analysis_dir"].format(analysis=wildcards.analysis, paramset=wildcards.paramset)
    script:
        "scripts/protein_analysis/run_conservation_analysis_batch.py"

# Generate comprehensive epitope conservation analysis report
rule generate_epitope_conservation_report:
    input:
        conservation_analysis_sentinel=config["paths"]["epitopes"]["conservation_analysis_sentinel"]
    output:
        conservation_report=config["paths"]["epitopes"]["conservation_report"]
    params:
        analysis="{analysis}",
        paramset="{paramset}",
        conservation_analysis_dir=lambda wildcards: config["paths"]["epitopes"]["conservation_analysis_dir"].format(analysis=wildcards.analysis, paramset=wildcards.paramset)
    script:
        "scripts/protein_analysis/generate_epitope_conservation_report.py"

# Compile integrated analysis report combining all pipeline results
# EXCLUDED: This rule has been excluded as it tries to access data from the download pipeline
# The analysis pipeline should only contain results generated by this Snakemake workflow
# rule generate_final_report:
#     input:
#         quality_positive=lambda wildcards: config["paths"]["quality"][f"assessment_{wildcards.use_3d_dir}"].replace("{group}", "positive").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
#         quality_negative=lambda wildcards: config["paths"]["quality"][f"assessment_{wildcards.use_3d_dir}"].replace("{group}", "negative").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
#         conservation_positive=lambda wildcards: config["paths"]["conservation"][f"results_{wildcards.use_3d_dir}"].replace("{group}", "positive").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
#         conservation_negative=lambda wildcards: config["paths"]["conservation"][f"results_{wildcards.use_3d_dir}"].replace("{group}", "negative").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
#         proteins_to_study_positive=lambda wildcards: config["paths"]["input"]["proteins_to_study"].replace("{group}", "positive").format(analysis=wildcards.analysis, paramset=wildcards.paramset),
#         proteins_to_study_negative=lambda wildcards: config["paths"]["input"]["proteins_to_study"].replace("{group}", "negative").format(analysis=wildcards.analysis, paramset=wildcards.paramset)
#     output:
#         config["paths"]["reports"]["final_report"]
#     params:
#         analysis="{analysis}",
#         paramset="{paramset}",
#         use_3d_dir="{use_3d_dir}"
#     script:
#         config["scripts"]["reports"]["generate_final_report"]